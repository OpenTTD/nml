import subprocess, os

def get_child_output(cmd, env=None, stderr=None):
    """
    Run a child process, and collect the generated output.

    @param cmd: Command to execute.
    @type  cmd: C{list} of C{str}

    @param env: Environment
    @type  env: C{dict}

    @param stderr: Pipe destination for stderr
    @type  stderr: file object

    @return: Generated output of the command, split on whitespace.
    @rtype:  C{list} of C{str}
    """
    return subprocess.check_output(cmd, universal_newlines = True, env=env, stderr=stderr).split()


def get_git_version(detailed = False):
    # method adopted shamelessly from OpenTTD's findversion.sh
    path = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
    version = ''
    env = dict(os.environ, LC_ALL='C')
    if os.path.isdir(os.path.join(path,'.git')):
        # Refresh the index to make sure file stat info is in sync
        try:
            get_child_output(["git", "-C", path, "update-index", "--refresh"], env=env)
        except:
            pass

        # Look for modifications
        try:
            modified  = (len(get_child_output(["git", "-C", path, "diff-index", "HEAD"], env=env)) > 0)
            isodate   = get_child_output(["git", "-C", path, "show", "-s", "--pretty=%ci", "HEAD"], env=env)[0]
            # git describe output is <tag>-<commits since tag>-<hash>, and <tag> may contain '-'
            describe  = get_child_output(["git", "-C", path, "describe", "--tags", "--long"], env=env)[0].rsplit('-', 2)
            tag = describe[0]
            release = describe[1] == "0"
            changeset = describe[2]
        except OSError as e:
            print("Git checkout found but cannot determine its version. Error({0}): {1}".format(e.errno, e.strerror))
            return version
        except subprocess.CalledProcessError as e:
            print("Git checkout found but cannot determine its version. Error: ", e)
            return version
        # A detached head will make the command fail, but it's uncritical
        # Treat it like branch 'master'.
        try:
            branch = get_child_output(["git", "-C", path, "symbolic-ref", "-q", "HEAD"], env=env)[0].split('/')[-1]
        except subprocess.CalledProcessError:
            branch = "master"

        # Compose the actual version string following PEP440
        version = tag.replace("-", "").lower()
        if not release:
            version += ".post0.dev" + isodate.replace("-", "") + "+"
            if branch != "master":
                version += branch + "."
            version += changeset

        if modified:
            version += "m"

        if detailed:
            version = changeset + ";" + branch + ";" + tag + ";" + str(release) + ";" + str(modified) + ";" + isodate + ";" + version

    return version

def get_and_write_version():
    # If the source is in a git repository, retrieve
    #  the current version from git and update __version__.py
    version = get_git_version()
    if version:
        try:
            path = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
            f = open(os.path.join(path, "nml", "__version__.py"), "w")
            f.write('# this file is autogenerated by setup.py\n')
            f.write('version = "{}"\n'.format(version))
            f.close()
            return version.split()[0]
        except IOError:
            print("Version file NOT written")
